1. 把组件当普通元素使用

   - 在组件上绑定属性=>props，如果没有给v-bind传入被绑定对象，这个时候绑定对象必须是对象，且其属性和props里面的属性一一对应

   - 在组件上定义原生事件=>一般情况下组件上只能监听有子组件定义过来的自定义事件，无法监听原生事件，可以通过添加.native修饰符，但这要求组件根元素有对应的原生事件；如果没办法加.native修饰符，但是可以分发组件事件，如果某个子元素需要该监听事件的行为则可以重写该事件监听函数，并通过v-on绑定该监听函数。

   - 在组件上放置普通静态属性=>会继承给该组件的根元素，这种继承除了style和class是添加的，其他的都是静默覆盖的；

   - 在组件上使用v-model=>默认是绑定给了props中的value变量，当然可以修改这一默认行为，v-model本质也是绑定语法，所有也就不难想象会把值自动绑定到props中。



2. 把插槽当成普通元素使用

   - 前面的语法均适用于组件，对于slot又有一套规则，不过slot会被代替，所以没必要定于事件、属性什么的，唯一可能需要的就是在父级作用域替换插槽的时候，对于插槽中的数据需要访问，这个时候就涉及插槽之间的通信了。

     同样地，插槽之间的数据访问，也是通过props，比如：

     在定义插槽的时候<slot :values="titles">这就默认把values作为一个插槽prop，绑定的是内部的titles变量，当然如果有多个绑定的化，就会形成一个props对象，所以在父组件中访问的时候，是通过：

     插槽对象.其中一个prop 来访问的，其中插槽对象可以随意命名，比如这里我想访问titles，slotprop.values即可





**Tips:** v-model其实本质是是事件和v-bind的结合体，一般只用于表单元素，表单元素，如果含有value属性，那么绑定的就是value属性的值，否则可能是布尔值，也可能是其他的原始变量类型





全局注册组件Vue.component(ID, {}),第二个是个对象，

也可以只要Vue.extend()对第二个对象做一层包装也是可以的，这个对象一般会至少含有2个属性，一个是data，一个是template，template可以放在外面定义。





**level 1 组件**：一种除了实现双向绑定，没什么其他功能

===================================================》

**level 2 组件**：实现了父子组件的数据通信，用户可以更好的通过组件的接口改变组件的行为

但是这种组件有缺点，就是用户虽然通过props对组件的数据以及属性有更多控制，但是

没办法控制组件内部的元素类型；所以这一阶段使用组件仅仅是用组件没办法在组件内插入元素

===================================================》

**level 3 组件**：通过slot组件，赋予了用户更好地控制组件的子元素类型，比如书上所说的例子

根据用户提供的元素，去得到用户想要的组件；这一阶段可以在使用组件的时候插入元素，并

相应根据插槽名分发内容，可以通过vue.$slots.name得到这个 在组件使用时分发的内容，

比如有一个名为foo的slot，在使用时会通过<template v-slot="foo"></template>

给对应插槽分发内容（*），然后可以通过vue.$slots.foo得到这个分发的内容。

（*）表示这个组件分发的内容

